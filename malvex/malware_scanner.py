# malvex/malware_scanner.py
import shutil
import time
from pathlib import Path
from typing import Dict, List, Optional, Callable # Callable for progress_callback

from .app_config import config
from .app_logger import Logger
from .signature_db import SignatureDatabase
from .archive_scanner import ArchiveScanner
from .realtime_monitor import RealTimeMonitor
from .file_utils import FileHasher
from .yara_scanner import YaraScanner
from .static_analyzer import StaticAnalyzer

class MalwareScanner:
    """Enhanced malware scanner with all features"""
    
    def __init__(self, logger: Logger):
        self.logger = logger
        self.sig_db = SignatureDatabase() # Scanner owns its SignatureDatabase
        self.archive_scanner = ArchiveScanner(logger, self.sig_db) # Scanner owns its ArchiveScanner
        self.realtime_monitor: Optional[RealTimeMonitor] = None # Initialize as None
        self.yara_scanner = YaraScanner(Path(__file__).parent / "yara_rules")
        self.static_analyzer = StaticAnalyzer()
        self.scanning = False
        self.scan_stats = {
            "files_scanned": 0,
            "threats_found": 0,
            "archives_scanned": 0,
            "errors": 0
        }
    
    def reset_scan_stats(self):
        self.scan_stats = {
            "files_scanned": 0,
            "threats_found": 0,
            "archives_scanned": 0,
            "errors": 0
        }

    def scan_file(self, file_path: Path, auto_action: Optional[str] = None) -> Dict:
        """Scan a single file"""
        result = {
            "file": str(file_path),
            "status": "clean", # Default status
            "threats": [],
            "action_taken": None
        }
        
        try:
            # Skip if file doesn't exist or is not a file (e.g. broken symlink)
            if not file_path.is_file():
                result["status"] = "skipped_not_file"
                return result

            # Skip quarantine directory to prevent re-scanning or accidental deletion
            # Check if file_path is within config.quarantine_dir
            if config.quarantine_dir.resolve() in file_path.resolve().parents:
                result["status"] = "skipped_in_quarantine"
                return result
            
            # Check if it's an archive
            if file_path.suffix.lower() in config.archive_types:
                self.scan_stats["archives_scanned"] += 1
                archive_threats = self.archive_scanner.scan_archive(file_path)
                if archive_threats:
                    result["status"] = "infected"
                    result["threats"] = archive_threats # This is a list of dicts
                    # The number of threats within an archive can be > 1
                    self.scan_stats["threats_found"] += len(archive_threats) 
            else:
                # Regular file scan
                md5_hash, sha256_hash = FileHasher.get_hashes(file_path)
                if md5_hash and sha256_hash: # Hashes were successfully computed
                    is_malicious, hash_types = self.sig_db.is_malicious(md5_hash, sha256_hash)
                    if is_malicious:
                        result["status"] = "infected"
                        # For non-archive files, threat is the file itself
                        result["threats"] = [{
                            "file": str(file_path.name),
                            "hash_types": hash_types,  # List of all matching types
                            "md5": md5_hash,
                            "sha256": sha256_hash
                        }]
                        self.scan_stats["threats_found"] += 1
                elif md5_hash is None and sha256_hash is None: # Hashing failed
                    result["status"] = "error_hashing"
                    self.scan_stats["errors"] += 1
                    self.logger.log(f"Could not hash file (likely permission issue): {file_path}", "WARNING")

                # YARA rule scanning
                if result["status"] == "clean":
                    yara_hits = self.yara_scanner.scan_file(file_path)
                    if yara_hits:
                        result["status"] = "infected"
                        result.setdefault("threats", []).append({
                            "file": str(file_path.name),
                            "yara_rules": yara_hits
                        })
                        self.scan_stats["threats_found"] += 1

                # Static feature scoring
                if result["status"] == "clean":
                    analysis = self.static_analyzer.analyze(file_path)
                    result["static_score"] = analysis["score"]
                    result["static_reasons"] = analysis["reasons"]
                    if analysis["score"] >= self.static_analyzer.threshold:
                        result["status"] = "suspicious"

            self.scan_stats["files_scanned"] += 1
            
            # Handle threats if found (applies to the main file_path, not files within archives directly here)
            if result["status"] == "infected" and auto_action:
                # Ensure this action is for the main file_path, not contents of archives
                # which should be handled based on user preference if GUI exists
                if not file_path.suffix.lower() in config.archive_types: # only auto-action non-archives
                    if auto_action == "quarantine":
                        if self.quarantine_file(file_path):
                            result["action_taken"] = "quarantined"
                            self.logger.log(f"Auto-quarantined: {file_path}", "WARNING")
                    elif auto_action == "delete":
                        if self.delete_file(file_path):
                            result["action_taken"] = "deleted"
                            self.logger.log(f"Auto-deleted: {file_path}", "WARNING")
                elif file_path.suffix.lower() in config.archive_types:
                     self.logger.log(f"Infected archive found: {file_path}. Manual action recommended for archives.", "WARNING")

        except PermissionError:
            self.logger.log(f"Permission denied accessing {file_path}", "ERROR")
            result["status"] = "error_permission"
            self.scan_stats["errors"] += 1
            # return result # ensure you return the resut dict to continue
        except OSError as e: # Catch other OS-related errors like file not found after listing
            self.logger.log(f"OS error processing file {file_path}: {e}", "ERROR")
            result["status"] = "error_os"
            self.scan_stats["errors"] += 1
            # return
        except Exception as e:
            self.logger.log(f"Error scanning {file_path}: {e}", "ERROR")
            result["status"] = "error_generic"
            self.scan_stats["errors"] += 1
        
        return result
    
    def scan_directory(self, directory_path: Path, 
                       progress_callback: Optional[Callable[[float, str], None]] = None) -> List[Dict]:
        """Scan a directory recursively"""
        results: List[Dict] = []
        self.scanning = True
        self.reset_scan_stats() # Reset stats for this scan session
        
        try:
            # Efficiently iterate through files, handling potential errors
            files_to_scan = []
            for item in directory_path.rglob("*"):
                if item.is_file():
                    files_to_scan.append(item)
            
            total_files = len(files_to_scan)
            if total_files == 0 and progress_callback:
                progress_callback(100.0, "No files found to scan.")


            for i, file_path in enumerate(files_to_scan):
                if not self.scanning:  # Check for cancellation
                    self.logger.log("Scan cancelled by user.", "INFO")
                    break 
                
                scan_result = self.scan_file(file_path)
                results.append(scan_result)
                
                if progress_callback:
                    progress = ((i + 1) / total_files) * 100 if total_files > 0 else 100
                    progress_callback(progress, str(file_path.name)) # Display file name
        
        except PermissionError:
            self.logger.log(f"Permission denied accessing directory contents: {directory_path}", "ERROR")
            self.scan_stats["errors"] +=1
        except Exception as e:
            self.logger.log(f"Error scanning directory {directory_path}: {e}", "ERROR")
            self.scan_stats["errors"] +=1
        
        finally: # Ensure scanning flag is reset
            self.scanning = False
        
        return results
    
    def quarantine_file(self, file_path: Path) -> bool:
        """Move file to quarantine"""
        if not file_path.exists():
            self.logger.log(f"File not found for quarantine: {file_path}", "ERROR")
            return False
        try:
            config.quarantine_dir.mkdir(parents=True, exist_ok=True) # Ensure quarantine dir exists
            # Append timestamp to avoid name collisions and keep original extension
            original_name = file_path.name
            timestamp = int(time.time())
            quarantined_file_name = f"{original_name}.{timestamp}.quarantined"
            quarantine_path = config.quarantine_dir / quarantined_file_name
            
            shutil.move(str(file_path), str(quarantine_path))
            self.logger.log(f"File quarantined: {file_path} -> {quarantine_path}")
            return True
        except Exception as e:
            self.logger.log(f"Quarantine failed for {file_path}: {e}", "ERROR")
            return False
    
    def delete_file(self, file_path: Path) -> bool:
        """Delete file permanently"""
        if not file_path.exists():
            self.logger.log(f"File not found for deletion: {file_path}", "ERROR")
            return False
        try:
            file_path.unlink()
            self.logger.log(f"File deleted: {file_path}")
            return True
        except Exception as e:
            self.logger.log(f"Delete failed for {file_path}: {e}", "ERROR")
            return False
    
    def start_realtime_protection(self):
        """Start real-time monitoring"""
        if not self.realtime_monitor:
            self.realtime_monitor = RealTimeMonitor(self.realtime_scan_callback)
        
        # Ensure monitor_paths in config are valid and exist
        valid_paths = [p for p in config.monitor_paths if Path(p).is_dir()]
        if not valid_paths:
            self.logger.log("No valid paths configured for real-time monitoring.", "WARNING")
            # Don't set realtime_enabled to True if no paths are monitored.
            config.realtime_enabled = False 
            config.save_config()
            return

        self.realtime_monitor.start_monitoring(valid_paths)
        config.realtime_enabled = True # Set to true only if monitor started successfully
        config.save_config()
        self.logger.log(f"Real-time protection started on: {', '.join(valid_paths)}")
    
    def stop_realtime_protection(self):
        """Stop real-time monitoring"""
        if self.realtime_monitor:
            self.realtime_monitor.stop_monitoring()
        
        config.realtime_enabled = False
        config.save_config()
        self.logger.log("Real-time protection stopped")
    
    def realtime_scan_callback(self, file_path: Path):
        """Callback for real-time scanning, automatically quarantines threats."""
        self.logger.log(f"Real-time: File change detected: {file_path}", "DEBUG") # Debug level
        # For real-time, default to quarantine. User can restore/delete from GUI.
        result = self.scan_file(file_path, auto_action="quarantine") 
        if result["status"] == "infected":
            self.logger.log(f"Real-time threat detected and action taken ('{result.get('action_taken', 'none')}'): {file_path}", "WARNING")
            # Potentially send a desktop notification here if GUI is active or via a system utility.