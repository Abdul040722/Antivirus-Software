# malvex/malware_scanner.py
from __future__ import annotations

import shutil
import threading
from pathlib import Path
from typing import Callable, Dict, List, Optional, Tuple

from .app_config import config
from .app_logger import Logger
from .file_utils import FileHasher
from .signature_db import SignatureDatabase
from .archive_scanner import ArchiveScanner
from .realtime_monitor import RealTimeMonitor
from .behavior_engine import BehaviorEngine
from .yara_scanner import YaraScanner, YaraMatch
from .app_config import config


Result = Dict[str, object]
ProgressCallback = Callable[[float, str], None]
NotifyCallback = Callable[[Result], None]  # NEW

class MalwareScanner:
    """
    Signature-based scanner with archive inspection and optional real-time monitoring.
    Now includes explicit quarantine/delete helpers that the GUI/CLI can call after prompting.
    """

    def __init__(self, logger: Logger, notify_callback: Optional[NotifyCallback] = None):
        self.logger = logger
        self.sig_db = SignatureDatabase()
        self.archive_scanner = ArchiveScanner(self.logger, self.sig_db)

        self.realtime: Optional[RealTimeMonitor] = None
        self._rt_lock = threading.Lock()

        self.scan_stats = {
            "files_scanned": 0,
            "threats_found": 0,
            "archives_scanned": 0,
            "errors": 0,
        }
        self.scanning = False

        # NEW: optional notifier invoked on real-time infections
        self.notify_threat: Optional[NotifyCallback] = notify_callback
        self.behavior: Optional[BehaviorEngine] = None

        try:
            self.yara_scanner = YaraScanner(self.logger)
        except Exception as e:
            self.logger.log(f"YARA init failed: {e}", "ERROR")
            self.yara_scanner = None  # degrade gracefully

    # ---------- Real-time ----------
    def start_realtime_protection(self):
        with self._rt_lock:
            if self.realtime:
                try:
                    self.realtime.stop_monitoring()
                except Exception:
                    pass
                self.realtime = None

            self.realtime = RealTimeMonitor(self._realtime_scan_callback)
            paths = list(config.monitor_paths or [])
            if not paths:
                self.logger.log("No monitor paths configured; cannot start real-time.", "WARNING")
                config.realtime_enabled = False
                config.save_config()
                return

            self.realtime.start_monitoring(paths)
            config.realtime_enabled = True
            config.save_config()
            self.logger.log("Real-time protection started.", "INFO")

    def stop_realtime_protection(self):
        with self._rt_lock:
            if self.realtime:
                try:
                    self.realtime.stop_monitoring()
                except Exception as e:
                    self.logger.log(f"Error stopping real-time: {e}", "ERROR")
                self.realtime = None
        config.realtime_enabled = False
        config.save_config()

    def _realtime_scan_callback(self, file_path: Path):
        """
        Called by RealTimeMonitor when a file stabilizes. We perform a single-file scan.
        If infected, notify via registered callback (GUI/CLI) or at least log.
        """
        try:
            result = self.scan_file(file_path)
            if result.get("status") == "infected":
                self.logger.log(f"Real-time threat detected: {file_path}", "WARNING")
                if self.notify_threat:
                    # Let the UI/CLI decide what to do (prompt user).
                    try:
                        self.notify_threat(result)
                    except Exception as cb_e:
                        self.logger.log(f"Notifier error for {file_path}: {cb_e}", "ERROR")
                else:
                    # Fallback visibility so it never feels silent.
                    self.logger.log(
                        "No notifier registered; run a manual scan or configure GUI/CLI prompts.",
                        "INFO"
                    )
        except Exception as e:
            self.logger.log(f"Real-time scan error for {file_path}: {e}", "ERROR")

    # ---------- Quarantine/Delete helpers ----------
    def quarantine_path(self, path: Path) -> Tuple[bool, str]:
        """
        Move the given path into quarantine folder with a unique name.
        Returns (success, dest_path_str_or_error).
        """
        try:
            if not path.exists():
                return False, "Source no longer exists."

            config.quarantine_dir.mkdir(parents=True, exist_ok=True)
            base = path.name
            dest = config.quarantine_dir / f"{base}.{path.stat().st_size}.quarantined"

            # If same name exists, dedupe
            counter = 1
            while dest.exists():
                dest = config.quarantine_dir / f"{base}.{path.stat().st_size}.{counter}.quarantined"
                counter += 1

            shutil.move(str(path), str(dest))
            self.logger.log(f"Quarantined: {path} -> {dest}", "WARNING")
            return True, str(dest)
        except Exception as e:
            self.logger.log(f"Failed to quarantine {path}: {e}", "ERROR")
            return False, str(e)

    def delete_path(self, path: Path) -> Tuple[bool, str]:
        """
        Permanently delete the given path. Returns (success, message).
        """
        try:
            if path.is_dir():
                shutil.rmtree(path, ignore_errors=False)
            else:
                path.unlink(missing_ok=False)
            self.logger.log(f"Deleted: {path}", "WARNING")
            return True, "Deleted"
        except Exception as e:
            self.logger.log(f"Failed to delete {path}: {e}", "ERROR")
            return False, str(e)

    # ---------- Behavior monitor control ----------
    def start_behavior_monitor(self, notify_callback: Optional[NotifyCallback] = None) -> None:
        """
        Starts the behavioral monitor. If a callback is supplied, it receives incidents:
          callback(incident_dict)
        The engine suspends suspicious PIDs first; you can then prompt the user and apply actions.
        """
        try:
            if self.behavior:
                return
            self.behavior = BehaviorEngine(self.logger, notify_incident=notify_callback)
            self.behavior.start()
            # Optional: feed FS events from our realtime monitor if available
            if self.realtime:
                # Augment RealTimeMonitor to forward create/modify events into behavior engine
                orig_created = self.realtime.on_created if hasattr(self.realtime, "on_created") else None
                orig_modified = self.realtime.on_modified if hasattr(self.realtime, "on_modified") else None

                # We already subclass FileSystemEventHandler; we can extend via wrapper methods.
                # NOTE: This is safe because it only forwards to behavior engine; it doesn't remove existing behavior.
                def _wrap_created(ev):
                    try:
                        if orig_created:
                            orig_created(ev)
                    finally:
                        try:
                            from watchdog.events import FileCreatedEvent
                            if isinstance(ev, FileCreatedEvent):
                                self.behavior.ingest_fs_create(Path(ev.src_path))
                        except Exception:
                            pass

                def _wrap_modified(ev):
                    try:
                        if orig_modified:
                            orig_modified(ev)
                    finally:
                        try:
                            from watchdog.events import FileModifiedEvent
                            if isinstance(ev, FileModifiedEvent):
                                self.behavior.ingest_fs_modify(Path(ev.src_path))
                        except Exception:
                            pass

                # Monkey-patch the instance methods safely
                self.realtime.on_created = _wrap_created  # type: ignore[attr-defined]
                self.realtime.on_modified = _wrap_modified  # type: ignore[attr-defined]

            self.logger.log("Behavior monitor started.", "INFO")
        except Exception as e:
            self.logger.log(f"Failed to start behavior monitor: {e}", "ERROR")

    def stop_behavior_monitor(self) -> None:
        try:
            if self.behavior:
                self.behavior.stop()
                self.behavior = None
                self.logger.log("Behavior monitor stopped.", "INFO")
        except Exception as e:
            self.logger.log(f"Failed to stop behavior monitor: {e}", "ERROR")

    # ---------- Scanning ----------
    def scan_file(self, file_path: Path, auto_action: Optional[str] = None) -> Result:
        """
        Scan a single file (or archive). If auto_action in {"quarantine","delete"}, apply when infected.
        Returns a structured result dict used by CLI and GUI.
        """
        res: Result = {
            "file": str(file_path),
            "status": "clean",
        }

        # Skip non-files early
        try:
            if not file_path.exists() or not file_path.is_file():
                res["status"] = "skipped_not_file"
                return res
        except Exception:
            res["status"] = "skipped_not_file"
            return res

        try:
            self.scan_stats["files_scanned"] += 1

            # --- Archive branch ---------------------------------------------------
            if file_path.suffix.lower() in config.archive_types:
                self.scan_stats["archives_scanned"] += 1
                threats_in_archive = self.archive_scanner.scan_archive(file_path)
                if threats_in_archive:
                    self.scan_stats["threats_found"] += 1
                    res["status"] = "infected"
                    res["threats"] = threats_in_archive
                    if auto_action in {"quarantine", "delete"}:
                        self._apply_auto_action(res, file_path, auto_action)
                return res

            # --- Non-archive path: YARA BEFORE hashes/signature DB ---------------
            yara_hits = []
            if getattr(config, "yara_enabled", False) and getattr(self, "yara_scanner", None):

                def _coerce_yara_strings(strings_obj) -> list:
                    """Safely coerce YARA strings to a UI-friendly list, capped at 10."""
                    out = []
                    try:
                        for s in (strings_obj or [])[:10]:
                            # python-yara typically returns tuples: (offset, identifier, data)
                            if isinstance(s, (tuple, list)) and len(s) >= 3:
                                out.append({"offset": s[0], "identifier": s[1], "data": s[2]})
                            elif hasattr(s, "__dict__"):
                                # Some wrappers may provide objects; best effort dump
                                out.append({k: v for k, v in s.__dict__.items()})
                            else:
                                out.append(str(s))
                    except Exception:
                        # Be resilient; if anything goes wrong, return what we have
                        pass
                    return out

                try:
                    ymatches, yerr = self.yara_scanner.scan_file(file_path)
                    if yerr and yerr not in {None, "not_a_file"}:
                        # Soft warn; continue with signature hashing
                        self.logger.log(f"YARA note for {file_path}: {yerr}", "DEBUG")

                    # Convert to threat descriptors expected by CLI/GUI (Type(s): YARA)
                    for m in ymatches:
                        yara_hits.append({
                            "file": str(file_path),
                            "yara_rule": getattr(m, "rule", None),
                            "yara_tags": getattr(m, "tags", []),
                            "yara_meta": getattr(m, "meta", {}),
                            "yara_score": getattr(m, "score", None),
                            "yara_strings": _coerce_yara_strings(getattr(m, "strings", [])),
                            "hash_types": ["YARA"],  # IMPORTANT: keeps your UI consistent
                        })
                except Exception as e:
                    self.logger.log(f"YARA scan error for {file_path}: {e}", "ERROR")

            # If YARA hits exist, mark infected and optionally auto-action
            if yara_hits:
                self.scan_stats["threats_found"] += 1
                res["status"] = "infected"
                res["threats"] = yara_hits

                if auto_action in {"quarantine", "delete"}:
                    self._apply_auto_action(res, file_path, auto_action)
                # IMPORTANT: Do NOT call self.notify_threat here.
                # Manual scans are prompted by CLI/GUI after the scan completes.
                return res

            # --- Regular file hashing/signature DB (executes when no YARA hit) ---
            md5_hash, sha256_hash = FileHasher.get_hashes(file_path)
            if not md5_hash or not sha256_hash:
                res["status"] = "error_hashing"
                self.scan_stats["errors"] += 1
                return res

            is_mal, hash_types = self.sig_db.is_malicious(md5_hash, sha256_hash)
            if is_mal:
                self.scan_stats["threats_found"] += 1
                res["status"] = "infected"
                res["threats"] = [{
                    "file": str(file_path),
                    "hash_types": hash_types,
                    "md5": md5_hash,
                    "sha256": sha256_hash,
                }]
                if auto_action in {"quarantine", "delete"}:
                    self._apply_auto_action(res, file_path, auto_action)

            return res

        except Exception as e:
            # Guardrail: never crash a full scan because of one file
            self.scan_stats["errors"] += 1
            res["status"] = "error_scanning"
            res["error"] = str(e)
            self.logger.log(f"Scan error for {file_path}: {e}", "ERROR")
            return res


    def scan_directory(
        self,
        root_path: Path,
        progress_callback: Optional[ProgressCallback] = None,
        auto_action: Optional[str] = None,
    ) -> List[Result]:
        """
        Recursively scan a directory. Returns a list of file results.
        """
        self.scanning = True
        results: List[Result] = []

        all_files: List[Path] = []
        try:
            for p in root_path.rglob("*"):
                if not p.is_file():
                    continue
                all_files.append(p)
        except Exception as e:
            self.logger.log(f"Error enumerating files under {root_path}: {e}", "ERROR")

        total = len(all_files) if all_files else 1

        for idx, p in enumerate(all_files, start=1):
            if not self.scanning:
                break
            current = str(p)
            if progress_callback:
                try:
                    progress_callback((idx / total) * 100.0, current)
                except Exception:
                    pass
            results.append(self.scan_file(p, auto_action=auto_action))

        self.scanning = False
        return results

    # ---------- Internals ----------
    def _apply_auto_action(self, result: Result, file_path: Path, auto_action: str) -> None:
        """
        Apply quarantine/delete automatically and annotate the result with 'action_taken' & 'action_ok'.
        For archive detections, act on the archive itself.
        """
        target = file_path
        if file_path.suffix.lower() in config.archive_types:
            # act on the archive as a whole
            target = file_path

        if auto_action == "quarantine":
            ok, msg = self.quarantine_path(target)
            result["action_taken"] = "quarantine"
            result["action_ok"] = ok
            if not ok:
                self.scan_stats["errors"] += 1
                result["action_error"] = msg
        elif auto_action == "delete":
            ok, msg = self.delete_path(target)
            result["action_taken"] = "delete"
            result["action_ok"] = ok
            if not ok:
                self.scan_stats["errors"] += 1
                result["action_error"] = msg
